---
name: java-unit-test-generator
description: 为 Java 类生成高质量的 JUnit 5 单元测试，支持 Mockito 模拟、Spring Boot 测试、边界场景覆盖。当用户需要编写单元测试、生成测试用例、提高测试覆盖率时使用。
---

# Java 单元测试生成器

当用户要求为 Java 类生成单元测试、编写测试用例、或提高代码覆盖率时，执行以下标准化流程。

## 1. 前置分析（必须执行）

### 1.1 读取被测类
- 使用 Read 工具读取用户指定的 Java 文件
- 如果未指定路径，询问："请提供需要测试的 Java 类完整路径"

### 1.2 分析类结构
提取以下信息：
- **类名**、**包名**
- **所有 public 方法**（包括构造方法、getter/setter）
- **方法参数类型**、**返回值类型**、**抛出异常**
- **依赖的其他类**（成员变量、方法参数）
- **使用的注解**（@Service, @Repository, @Autowired 等）

### 1.3 确定测试框架
| 场景 | 测试框架 |
|------|---------|
| 纯 Java 类 | JUnit 5 + Mockito |
| Spring Boot 组件 | JUnit 5 + Mockito + @SpringBootTest/@ExtendWith |
| 数据库访问层 | @DataJpaTest 或 Testcontainers |
| Web 层 | @WebMvcTest 或 @WebFluxTest |

## 2. 测试生成规范

### 2.1 测试类结构
```java
package com.example.service;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.assertj.core.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * {@link UserService} 单元测试
 * 
 * @author Generated by AI
 * @since 2024-01-15
 */
@ExtendWith(MockitoExtension.class)  // 非 Spring 纯单元测试
class UserServiceTest {

    @InjectMocks
    private UserService userService;

    @Mock
    private UserRepository userRepository;

    @Mock
    private EmailService emailService;

    // 测试方法按功能分组
    // ==================== 查询操作 ====================
    
    @Test
    @DisplayName("根据ID查询用户-存在时返回用户")
    void findById_WhenUserExists_ReturnsUser() {
        // Arrange
        Long userId = 1L;
        User expectedUser = User.builder()
            .id(userId)
            .name("张三")
            .email("zhangsan@example.com")
            .build();
        when(userRepository.findById(userId)).thenReturn(Optional.of(expectedUser));

        // Act
        User actualUser = userService.findById(userId);

        // Assert
        assertThat(actualUser).isNotNull();
        assertThat(actualUser.getId()).isEqualTo(userId);
        assertThat(actualUser.getName()).isEqualTo("张三");
        verify(userRepository, times(1)).findById(userId);
    }

    @Test
    @DisplayName("根据ID查询用户-不存在时抛出异常")
    void findById_WhenUserNotExists_ThrowsException() {
        // Arrange
        Long userId = 999L;
        when(userRepository.findById(userId)).thenReturn(Optional.empty());

        // Act & Assert
        assertThatThrownBy(() -&gt; userService.findById(userId))
            .isInstanceOf(UserNotFoundException.class)
            .hasMessageContaining("用户不存在");
        
        verify(userRepository, times(1)).findById(userId);
    }

    // ==================== 写操作 ====================

    @Test
    @DisplayName("创建用户-成功时返回新用户")
    void createUser_WithValidData_ReturnsCreatedUser() {
        // Arrange
        UserCreateRequest request = new UserCreateRequest("李四", "lisi@example.com");
        User savedUser = User.builder()
            .id(2L)
            .name(request.getName())
            .email(request.getEmail())
            .build();
        
        when(userRepository.existsByEmail(request.getEmail())).thenReturn(false);
        when(userRepository.save(any(User.class))).thenReturn(savedUser);
        doNothing().when(emailService).sendWelcomeEmail(anyString());

        // Act
        User result = userService.createUser(request);

        // Assert
        assertThat(result.getId()).isEqualTo(2L);
        assertThat(result.getName()).isEqualTo("李四");
        verify(userRepository).existsByEmail(request.getEmail());
        verify(userRepository).save(any(User.class));
        verify(emailService).sendWelcomeEmail(request.getEmail());
    }

    @Test
    @DisplayName("创建用户-邮箱已存在时抛出异常")
    void createUser_WithDuplicateEmail_ThrowsException() {
        // Arrange
        UserCreateRequest request = new UserCreateRequest("李四", "lisi@example.com");
        when(userRepository.existsByEmail(request.getEmail())).thenReturn(true);

        // Act & Assert
        assertThatThrownBy(() -&gt; userService.createUser(request))
            .isInstanceOf(DuplicateEmailException.class);
        
        verify(userRepository, never()).save(any(User.class));
        verify(emailService, never()).sendWelcomeEmail(anyString());
    }

    // ==================== 边界场景 ====================

    @ParameterizedTest
    @ValueSource(strings = {"", " ", "invalid-email"})
    @DisplayName("创建用户-无效邮箱格式时抛出异常")
    void createUser_WithInvalidEmail_ThrowsException(String invalidEmail) {
        // Arrange
        UserCreateRequest request = new UserCreateRequest("王五", invalidEmail);

        // Act & Assert
        assertThatThrownBy(() -&gt; userService.createUser(request))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("邮箱格式不正确");
    }
}