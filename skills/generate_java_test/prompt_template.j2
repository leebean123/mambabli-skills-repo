你是一名资深 Java 开发工程师，擅长编写高质量、高覆盖率的单元测试。

## 任务
为以下 Java 类生成完整的 JUnit 5 单元测试类。要求：
- 使用 JUnit 5（@Test, @BeforeEach 等）
- 若涉及外部依赖，使用 Mockito 进行 mock
- 测试命名清晰（如 `shouldReturnEmptyListWhenInputIsNull`）
- 覆盖正常路径、边界条件和异常路径
- 不要包含 main 方法
- 输出仅包含 Java 代码，不要解释

## 被测类信息
类名：{{ class_name }}
{% if method_signature %}
目标方法：{{ method_signature }}
{% endif %}

## 源码
```java
{{ source_code }}

## 项目上下文（如有）
{% if project_deps %}
已知依赖：{{ project_deps | join(", ") }}
{% endif %}

## 出格式
直接输出完整的 .java 测试类代码，以 java 开头， 结尾。

---

### 3. `validators.py` —— 输出校验器

```python
import re
from typing import Dict, Any

def validate_java_test(output: str) -> Dict[str, Any]:
    """校验生成的 Java 测试是否合法"""
    issues = []

    # 检查是否包含 Java 代码块
    if not output.strip().startswith("```java"):
        issues.append("输出未以 ```java 开头")

    # 提取代码内容
    code_match = re.search(r"```java\s*(.*?)\s*```", output, re.DOTALL)
    if not code_match:
        return {"valid": False, "issues": ["无法提取 Java 代码块"]}

    code = code_match.group(1).strip()

    # 基本语法检查
    if "@Test" not in code:
        issues.append("缺少 @Test 注解")
    if "import org.junit.jupiter" not in code and "import static org.junit.jupiter" not in code:
        issues.append("未检测到 JUnit 5 导入")
    if not re.search(r"public class \w+Test", code):
        issues.append("测试类命名不符合 XxxTest 规范")

    # 检查是否包含被测类引用
    # （可根据实际 class_name 动态检查）

    return {
        "valid": len(issues) == 0,
        "issues": issues,
        "clean_code": code if code else output
    }


